import fs from 'node:fs';
import { posix } from 'node:path';

import openapiTS, { astToString } from 'openapi-typescript';

import { resolveObjectOrRef, resolveOpenapi } from './resolve';
import { strHump } from './utils';

const HEADER_CODE = `
/* eslint-disable eslint-comments/no-unlimited-disable */
/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// Generated by @xiankq/openapi-typescript-expand
// Power by openapi-typescript
`;

/**
 * openapiCodegen构造参数
 */
export interface OpenapiCodegenOptions {
  /**
   * 生成代码的路径文件
   */
  output: string;

  /**
   * 请求函数名称
   */
  requestName: string;

  /**
   * 文件头部添加的字符串
   */
  headerCode?: string;
}

export type HttpMethod = 'get' | 'put' | 'post' | 'delete' | 'options' | 'head' | 'patch' | 'trace';

export async function openapiTypescriptExpand(source: any, options: OpenapiCodegenOptions) {
  const output = `${posix.resolve(options.output)}`;

  const schema = await resolveOpenapi(source);
  const ast = await openapiTS(schema, {
    alphabetize: true,
    additionalProperties: true,
  });
  let content = astToString(ast);

  (() => {
    let ts = '';
    const pathKeys = Object.keys(schema.paths ?? {});
    pathKeys?.forEach((path) => {
      const data = resolveObjectOrRef(schema, schema.paths![path]).object;
      let dts = '';
      const methods = Object.keys(data) as HttpMethod[];
      methods.forEach((method) => {
        const operation = resolveObjectOrRef(schema, data[method]).object;
        if (!operation) {
          return;
        }
        const PATH_NAME = `${strHump(path, 'lower')}Using${strHump(method, 'upper')}`;
        const PATH_NAME_UPPER = strHump(PATH_NAME, 'upper');
        const TYPE_OPERATION = `${PATH_NAME_UPPER}Operation`;

        dts += `\n\nexport type ${TYPE_OPERATION} = paths['${path}']['${method}'];`;

        const parameters = operation.parameters?.map((e) => resolveObjectOrRef(schema, e).object);

        const headerParameters = parameters?.filter((e) => e.in === 'header');
        const pathParameters = parameters?.filter((e) => e.in === 'path');
        const queryParameters = parameters?.filter((e) => e.in === 'query');

        //header
        if (headerParameters?.length) {
          dts += `\n\nexport type ${PATH_NAME_UPPER}Header = ${TYPE_OPERATION}['parameters']['header']`;
        }

        //path
        if (pathParameters?.length) {
          dts += `\n\nexport type ${PATH_NAME_UPPER}Path = ${TYPE_OPERATION}['parameters']['path']`;
        }

        //query
        if (queryParameters?.length) {
          dts += `\n\nexport type ${PATH_NAME_UPPER}Query = ${TYPE_OPERATION}['parameters']['query']`;
        }

        const requestBody = resolveObjectOrRef(schema, operation.requestBody).object;
        const contentType = Object.keys(requestBody?.content ?? {})[0];

        //body
        if (contentType) {
          dts += `\n\nexport type ${PATH_NAME_UPPER}Body = Required<${TYPE_OPERATION}>['requestBody']['content']['${contentType}']`;
        }

        dts +=
          `\n\n` +
          `export interface ${PATH_NAME_UPPER}Options {` +
          `\n  [key: string]: unknown;` +
          `${headerParameters?.length ? `\n  header?: ${PATH_NAME_UPPER}Header;` : ''}` +
          `${pathParameters?.length ? `\n  path: ${PATH_NAME_UPPER}Path;` : ''}` +
          `${queryParameters?.length ? `\n  query: ${PATH_NAME_UPPER}Query;` : ''}` +
          `${contentType ? `\n  data: ${PATH_NAME_UPPER}Body;` : ''}` +
          `\n}`;

        const responses = resolveObjectOrRef(
          schema,
          Object.values(operation.responses ?? {})?.[0],
        ).object;
        const statusType = Object.keys(operation.responses ?? {})[0];
        const responseType = Object.keys(responses.content ?? {})[0];
        //response
        if (statusType && responseType) {
          dts += `\n\nexport type ${PATH_NAME_UPPER}Result = Required<${TYPE_OPERATION}>['responses']['${statusType}']['content']['${responseType}']`;
        } else {
          dts += `\n\nexport type ${PATH_NAME_UPPER}Result = any`;
        }

        const comment =
          `\n/**` +
          `\n${operation.tags?.map((e) => ` * @tag ${e}`).join('\n')}` +
          `\n * @summary ${operation.summary}` +
          `\n * @url ${path}` +
          `\n * @method ${method}` +
          `\n * @description ${operation.description ?? ''}` +
          `\n */`;

        ts +=
          `\n${comment}\n` +
          `export function ${PATH_NAME}(options:${PATH_NAME_UPPER}Options):Promise<${PATH_NAME_UPPER}Result> {` +
          `\n  return ${options.requestName}({` +
          `\n    ...options,` +
          `\n    url:'${path}',` +
          `\n    method:'${method}',` +
          `\n  });` +
          `\n}`;
      });
      content += dts;
    });

    content += ts;
  })();

  content = `${HEADER_CODE}\n` + `${options.headerCode ?? ''}` + `\n${content}`;
  fs.mkdirSync(posix.resolve(output, '../'), { recursive: true });
  fs.writeFileSync(posix.resolve(output), content);
}
